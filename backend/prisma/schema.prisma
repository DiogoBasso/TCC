generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "rhel-openssl-3.0.x"]
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

enum RoleName {
  ADMIN
  CPPD_MEMBER
  DOCENTE
}

model User {
  idUser       Int       @id @default(autoincrement())
  name         String    @db.VarChar(120)
  email        String    @unique @db.VarChar(180)
  cpf          String    @unique @db.VarChar(14)
  passwordHash String    @db.VarChar(200)
  active       Boolean   @default(true)
  createdAt    DateTime  @default(now())
  deletedDate  DateTime?
  updatedAt    DateTime  @updatedAt

  roles                UserRole[]
  docente              DocenteProfile?
  CareerProcess        CareerProcess[]
  ProcessStatusHistory ProcessStatusHistory[]

  @@map("user")
}

//tabela separada para facilitar futuras expansões (ex: grupos de permissões)
model Role {
  idRole      BigInt     @id @default(autoincrement())
  name        RoleName   @unique
  createdAt   DateTime   @default(now())
  deletedDate DateTime?
  updatedAt   DateTime   @updatedAt
  users       UserRole[]

  @@map("role")
}

model UserRole {
  userId      Int
  roleId      BigInt
  assignedAt  DateTime  @default(now())
  deletedDate DateTime?
  updatedAt   DateTime  @updatedAt

  user User @relation(fields: [userId], references: [idUser], onDelete: Cascade)
  role Role @relation(fields: [roleId], references: [idRole], onDelete: Cascade)

  @@id([userId, roleId])
  @@map("user_role")
}

//tabela com dados específicos do docente, para permitir perfil de docente e membro da CPPD
model DocenteProfile {
  idDocente            Int       @id @default(autoincrement())
  userId               Int       @unique
  siape                String    @db.VarChar(30)
  class                String    @db.VarChar(60)
  level                String    @db.VarChar(60)
  start_interstice     DateTime //data do início do interstício atual
  educationLevel       String    @db.VarChar(120)
  improvement          String?   @db.VarChar(120)
  specialization       String?   @db.VarChar(120)
  mastersDegree        String?   @db.VarChar(120)
  doctorate            String?   @db.VarChar(120)
  assignment           String?   @db.VarChar(120)
  department           String?   @db.VarChar(120)
  division             String?   @db.VarChar(120)
  role                 String?   @db.VarChar(120)
  immediate_supervisor String?   @db.VarChar(120)
  user                 User      @relation(fields: [userId], references: [idUser], onDelete: Cascade)
  createdAt            DateTime  @default(now())
  deletedDate          DateTime?
  updatedAt            DateTime  @updatedAt

  @@map("docente_profile")
}

model ScoringTable {
  idScoringTable Int       @id @default(autoincrement())
  name           String    @db.VarChar(120)
  startsOn       DateTime?
  endsOn         DateTime?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  deletedDate    DateTime?

  nodes         ScoringNode[]
  items         ScoringItem[]
  CareerProcess CareerProcess[]

  @@map("scoring_table")
}

model ScoringNode {
  idScoringNode  Int       @id @default(autoincrement())
  scoringTableId Int
  parentId       Int?
  name           String    @db.VarChar(150)
  code           String?   @db.VarChar(50) //código opcional para referência externa ex: "A1", "B2.1"
  sortOrder      Int       @default(0)
  active         Boolean   @default(true)
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  deletedDate    DateTime?

  table    ScoringTable  @relation(fields: [scoringTableId], references: [idScoringTable], onDelete: Cascade)
  parent   ScoringNode?  @relation("NodeChildren", fields: [parentId], references: [idScoringNode], onDelete: Cascade)
  children ScoringNode[] @relation("NodeChildren")

  items ScoringItem[]

  //evita duplicar nomes entre irmãos dentro da mesma tabela de pontuação
  @@unique([scoringTableId, parentId, name], name: "uq_sibling_name")
  @@index([scoringTableId, parentId, sortOrder])
  @@map("scoring_node")
}

model ScoringItem {
  idScoringItem  Int       @id @default(autoincrement())
  scoringTableId Int
  nodeId         Int
  description    String    @db.VarChar(255)
  points         Decimal   @db.Decimal(10, 2)
  unit           String?   @db.VarChar(30)
  hasMaxPoints   Boolean   @default(false)
  active         Boolean   @default(true)
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  deletedDate    DateTime?

  table        ScoringTable   @relation(fields: [scoringTableId], references: [idScoringTable], onDelete: Cascade)
  node         ScoringNode    @relation(fields: [nodeId], references: [idScoringNode], onDelete: Cascade)
  ProcessScore ProcessScore[]

  @@index([nodeId])
  @@map("scoring_item")
}

enum ProcessType {
  PROGRESSAO
  PROMOCAO
}

enum ProcessStatus {
  DRAFT //rascunho do docente
  SUBMITTED //enviado pelo docente
  UNDER_REVIEW //em análise pela CPPD
  APPROVED
  REJECTED
  RETURNED //devolvido ao docente para ajustes
}

model CareerProcess {
  idProcess      Int           @id @default(autoincrement())
  userId         Int
  scoringTableId Int //TABELA VIGENTE “fixada” no momento da abertura
  type           ProcessType
  status         ProcessStatus @default(DRAFT)
  submittedAt    DateTime?
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  deletedDate    DateTime?

  user  User         @relation(fields: [userId], references: [idUser], onDelete: Restrict)
  table ScoringTable @relation(fields: [scoringTableId], references: [idScoringTable], onDelete: Restrict)

  scores               ProcessScore[]
  ProcessStatusHistory ProcessStatusHistory[]

  @@index([userId, status])
  @@index([scoringTableId])
  @@map("process")
}

model ProcessScore {
  idProcessScore Int @id @default(autoincrement())
  processId      Int
  itemId         Int

  quantity      Int     @default(0) //para itens “por unidade”
  awardedPoints Decimal @db.Decimal(10, 2) //pontos efetivamente computados

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedDate DateTime?

  process       CareerProcess   @relation(fields: [processId], references: [idProcess], onDelete: Cascade)
  item          ScoringItem     @relation(fields: [itemId], references: [idScoringItem], onDelete: Restrict)
  ScoreEvidence ScoreEvidence[]

  @@unique([processId, itemId]) //1 linha por item no processo
  @@index([itemId])
  @@map("process_score")
}

model ProcessStatusHistory {
  idStatusHist Int            @id @default(autoincrement())
  processId    Int
  fromStatus   ProcessStatus?
  toStatus     ProcessStatus
  changedById  Int
  note         String?        @db.VarChar(500)
  updatedAt    DateTime       @default(now())
  createdAt    DateTime       @default(now())
  deletedDate  DateTime?

  process   CareerProcess @relation(fields: [processId], references: [idProcess], onDelete: Cascade)
  changedBy User          @relation(fields: [changedById], references: [idUser], onDelete: Restrict)

  @@index([processId, updatedAt])
  @@map("process_status_history")
}

model ScoreEvidence {
  idEvidence     Int       @id @default(autoincrement())
  processScoreId Int
  filename       String    @db.VarChar(180)
  url            String    @db.VarChar(500)
  mimeType       String?   @db.VarChar(60)
  sizeBytes      BigInt?
  uploadedAt     DateTime  @default(now())
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  deletedDate    DateTime?

  score ProcessScore @relation(fields: [processScoreId], references: [idProcessScore], onDelete: Cascade)

  @@index([processScoreId])
  @@map("score_evidence")
}
